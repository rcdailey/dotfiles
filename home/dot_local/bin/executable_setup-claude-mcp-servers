#!/usr/bin/env python3
"""Claude Code MCP Server Management Script

IMPLEMENTATION GUIDANCE FOR CONTRIBUTORS:
=========================================

This script follows a clean, deterministic architecture for MCP server configuration.
When adding new transport types, follow these patterns:

TRANSPORT TYPES:
- uvx: Package-based installation via uvx (uvx_package field)
- npx: Package-based installation via npx (npx_package field)
- script: Existing setup script execution (setup_script field)
- http: Direct HTTP transport to remote MCP services (http field)
- sse: Server-Sent Events transport to remote MCP services (sse field)
- bridge: Stdio transport via bridge script to remote services (bridge field)

ADDING NEW TRANSPORTS:
1. Add field to Server dataclass (e.g., "my_transport: str = None")
2. Create setup function (e.g., "setup_my_transport(name, server, dry_run)")
3. Add to setup decision tree in setup_server() with elif clause
4. Update dry-run logic to show what would be done

CONFIGURATION EXAMPLES:
- HTTP: {"name": "api", "http": "https://api.service.com/mcp", "scope": "user"}
- SSE: {"name": "rider", "sse": "http://localhost:64342/sse", "scope": "user"}
- Bridge: {"name": "remote", "bridge": "/path/to/bridge.js", "env": "KEY=value"}
- NPX: {"name": "tool", "npx": "@package/mcp-server", "env": "API_KEY=xyz"}

PRINCIPLES:
- Keep it deterministic: Each server config has exactly one transport type
- No custom_setup functions: Use standard patterns only
- Consistent parameter handling: env, scope, extra_args work the same way
- Clean separation: Each transport type has its own handler function

ENVIRONMENT VARIABLES:
Use resolve_env_var() helper for rbw/environment variable expansion in env strings.
"""

import sys
import subprocess
import os


# Auto-install dependencies
def ensure_deps():
    deps = ["typer", "rich", "sh"]
    missing = []
    for dep in deps:
        try:
            __import__(dep)
        except ImportError:
            missing.append(dep)

    if missing:
        print(f"Installing: {' '.join(missing)}")
        subprocess.check_call(
            [
                sys.executable,
                "-m",
                "pip",
                "install",
                "--user",
                "--break-system-packages",
                *missing,
            ]
        )


ensure_deps()

# Force Python to refresh its import cache after installing new packages
import importlib  # noqa: E402  # Import after ensure_deps() for dependency self-installation

importlib.invalidate_caches()

import typer  # noqa: E402  # Import after ensure_deps() for dependency self-installation
from rich.console import Console  # noqa: E402  # Import after ensure_deps() for dependency self-installation
from rich.table import Table  # noqa: E402  # Import after ensure_deps() for dependency self-installation
import sh  # noqa: E402  # Import after ensure_deps() for dependency self-installation
from typing import Dict, List  # noqa: E402  # Import after ensure_deps() for dependency self-installation
from dataclasses import dataclass  # noqa: E402  # Import after ensure_deps() for dependency self-installation

# =============================================================================
# MCP SERVERS TO MANAGE
# =============================================================================
# Add/remove servers here. All servers are configured at user scope (--user)

MCP_SERVERS = [
    # Octocode MCP - AI-powered code analysis and repository research
    {"name": "octocode", "script": "setup-octocode-mcp"},
    # MarkItDown MCP - installs via uvx
    {"name": "markitdown", "uvx": "markitdown-mcp"},
    # Tavily MCP - web search and content extraction
    {"name": "tavily", "npx": "tavily-mcp", "env": "TAVILY_API_KEY=rbw:tavily-api-key"},
    # Sequential Thinking MCP - structured problem-solving through thoughts
    {
        "name": "sequential-thinking",
        "npx": "@modelcontextprotocol/server-sequential-thinking",
    },
    # Rider MCP - IDE integration via SSE transport
    {
        "name": "rider",
        "sse": "http://localhost:64342/sse",
        "args": "user",  # scope
    },
]

# =============================================================================

console = Console()
app = typer.Typer(help="Manage Claude Code MCP Servers", no_args_is_help=False)


def resolve_env_var(env_string: str) -> str:
    """Resolve environment variables with secret lookups.

    Supports formats like:
    - VAR_NAME=rbw:secret-name (gets secret from rbw)
    - VAR_NAME=literal_value (uses literal value)
    - VAR_NAME (returns as-is for runtime resolution)
    """
    if "=" not in env_string:
        return env_string

    var_name, value = env_string.split("=", 1)

    if value.startswith("rbw:"):
        secret_name = value[4:]  # Remove "rbw:" prefix
        try:
            result = subprocess.run(
                ["rbw", "get", secret_name], capture_output=True, text=True, check=True
            )
            return f"{var_name}={result.stdout.strip()}"
        except subprocess.CalledProcessError as e:
            console.print(f"[red]Failed to get {secret_name} from rbw: {e}[/red]")
            console.print(
                "[red]This likely means rbw is not authenticated. Run 'rbw unlock' first.[/red]"
            )
            raise typer.Exit(1)

    # Return as-is for literal values or other formats
    return env_string


@app.callback(invoke_without_command=True)
def main_callback(
    ctx: typer.Context,
    dry_run: bool = typer.Option(False, "--dry-run", help="Show what would be done"),
    verbose: bool = typer.Option(False, "--verbose", help="Verbose output"),
):
    """Manage Claude Code MCP Servers. Runs sync by default."""
    if ctx.invoked_subcommand is None:
        # No subcommand was invoked, run sync
        sync(dry_run=dry_run, verbose=verbose)


@dataclass
class Server:
    name: str
    setup_script: str = None
    extra_args: str = ""
    uvx_package: str = None
    npx_package: str = None
    env_vars: str = None
    http: str = None
    sse: str = None
    bridge: str = None


def setup_http_transport(name: str, server: Server, dry_run: bool = False):
    """Set up MCP server using HTTP transport."""
    if dry_run:
        scope_info = f" --scope {server.extra_args}" if server.extra_args else ""
        console.print(
            f"[blue](DRY RUN) Would add {name} MCP server via HTTP transport to {server.http}{scope_info}[/blue]"
        )
        return

    console.print(f"[blue]Adding {name} MCP server via HTTP transport...[/blue]")

    # Build command arguments
    args = ["--transport", "http", name, server.http]

    # Add scope if specified in extra_args
    if server.extra_args:
        args.extend(["--scope", server.extra_args])

    # Add the MCP server using HTTP transport
    sh.claude.mcp.add(*args)


def setup_sse_transport(name: str, server: Server, dry_run: bool = False):
    """Set up MCP server using SSE transport."""
    if dry_run:
        scope_info = f" --scope {server.extra_args}" if server.extra_args else ""
        console.print(
            f"[blue](DRY RUN) Would add {name} MCP server via SSE transport to {server.sse}{scope_info}[/blue]"
        )
        return

    console.print(f"[blue]Adding {name} MCP server via SSE transport...[/blue]")

    # Build command arguments
    args = [name]

    # Add scope if specified in extra_args
    if server.extra_args:
        args.extend(["-s", server.extra_args])

    # Add environment variables
    if server.env_vars:
        resolved_env = resolve_env_var(server.env_vars)
        args.extend(["-e", resolved_env])

    # Add SSE transport and URL
    args.extend(["-t", "sse", server.sse])

    # Add the MCP server using SSE transport
    sh.claude.mcp.add(*args)


def setup_bridge_transport(name: str, server: Server, dry_run: bool = False):
    """Set up MCP server using bridge transport (stdio with bridge script)."""
    import urllib.request

    if dry_run:
        env_info = f" with env vars '{server.env_vars}'" if server.env_vars else ""
        console.print(
            f"[blue](DRY RUN) Would setup {name} using bridge script {server.bridge}{env_info}[/blue]"
        )
        return

    console.print(f"[blue]Setting up {name} using bridge transport...[/blue]")

    # Handle bridge script download if it's a URL
    bridge_path = server.bridge
    if server.bridge.startswith("http"):
        # Download bridge script to standard location
        bridge_dir = os.path.expanduser("~/.local/share/mcp-bridges")
        os.makedirs(bridge_dir, exist_ok=True)
        bridge_filename = server.bridge.split("/")[-1]
        bridge_path = os.path.join(bridge_dir, bridge_filename)

        console.print(f"[blue]Downloading bridge script to {bridge_path}...[/blue]")
        try:
            urllib.request.urlretrieve(server.bridge, bridge_path)
            os.chmod(bridge_path, 0o755)
        except Exception as e:
            raise Exception(f"Failed to download bridge script: {e}")
    else:
        # Expand tilde in local paths
        bridge_path = os.path.expanduser(server.bridge)
        if not os.path.exists(bridge_path):
            raise Exception(f"Bridge script not found: {bridge_path}")

    console.print(f"[blue]Adding {name} MCP server via bridge...[/blue]")

    # Build command arguments
    args = [name]

    # Add scope if specified in extra_args
    if server.extra_args:
        args.extend(["--scope", server.extra_args])

    # Add environment variables
    if server.env_vars:
        resolved_env = resolve_env_var(server.env_vars)
        args.extend(["--env", resolved_env])

    # Add stdio transport and bridge command
    args.extend(["--", "node", bridge_path])

    # Add the MCP server using bridge transport
    sh.claude.mcp.add(*args)


# Convert simple config to Server objects
DESIRED_SERVERS = {}
for config in MCP_SERVERS:
    DESIRED_SERVERS[config["name"]] = Server(
        name=config["name"],
        setup_script=config.get("script"),
        extra_args=config.get("args", ""),
        uvx_package=config.get("uvx"),
        npx_package=config.get("npx"),
        env_vars=config.get("env"),
        http=config.get("http"),
        sse=config.get("sse"),
        bridge=config.get("bridge"),
    )


def get_current_servers() -> Dict[str, dict]:
    """Get currently configured MCP servers."""
    try:
        # Use subprocess instead of sh library for better control
        result = subprocess.run(
            ["claude", "mcp", "list"], capture_output=True, text=True
        )
        if result.returncode != 0:
            return {}

        servers = {}
        for line in result.stdout.strip().split("\n"):
            if ":" in line and not line.startswith("Checking"):
                name = line.split(":")[0].strip()
                if name:
                    try:
                        details_result = subprocess.run(
                            ["claude", "mcp", "get", name],
                            capture_output=True,
                            text=True,
                        )
                        if details_result.returncode == 0:
                            config = parse_mcp_config(details_result.stdout)
                            servers[name] = config
                        else:
                            servers[name] = {"command": "unknown", "arguments": []}
                    except Exception:
                        console.print(
                            f"[yellow]Warning: Could not get details for {name}[/yellow]"
                        )
                        servers[name] = {"command": "unknown", "arguments": []}

        return servers
    except Exception:
        return {}


def parse_mcp_config(config_str: str) -> dict:
    """Parse claude mcp get output into structured config."""
    config = {"command": "", "arguments": [], "type": ""}

    for line in config_str.split("\n"):
        line = line.strip()
        if line.startswith("Type: "):
            config["type"] = line.replace("Type: ", "")
        elif line.startswith("Command: "):
            config["command"] = line.replace("Command: ", "")
        elif line.startswith("Args: "):
            args_str = line.replace("Args: ", "")
            config["arguments"] = [args_str] if args_str else []
        elif line.startswith("URL: "):
            # For HTTP transport
            config["url"] = line.replace("URL: ", "")

    return config


def analyze_state(current: Dict[str, dict]) -> tuple[List[str], List[str]]:
    """Analyze current vs desired state."""
    to_add = []
    up_to_date = []

    for name in DESIRED_SERVERS:
        if name in current:
            # Server exists, but check if configuration matches
            if needs_update(name, current[name]):
                to_add.append(name)  # Will remove and re-add
            else:
                up_to_date.append(name)
        else:
            to_add.append(name)

    return to_add, up_to_date


def needs_update(name: str, current_config: dict) -> bool:
    """Check if server configuration needs updating."""
    server = DESIRED_SERVERS[name]
    current_command = current_config.get("command", "")
    current_args = current_config.get("arguments", [])
    current_type = current_config.get("type", "")

    # Check transport type changes
    if server.npx_package:
        # NPX servers should have command=npx and package name in args
        if current_command != "npx":
            return True
        # Check if package name appears anywhere in the args string
        args_str = " ".join(current_args)
        return server.npx_package not in args_str

    elif server.uvx_package:
        # UVX servers should have command=uvx and package name in args
        if current_command != "uvx":
            return True
        args_str = " ".join(current_args)
        return server.uvx_package not in args_str

    elif server.setup_script:
        # Script-based servers use custom setup - check if they exist at all
        # If they exist, assume they're correct (scripts handle their own logic)
        return False

    elif server.http:
        # HTTP transport should have type=http
        return current_type != "http"

    elif server.sse:
        # SSE transport should have type=sse
        return current_type != "sse"

    elif server.bridge:
        # Bridge transport uses stdio with node command
        return current_command != "node"

    return False


def setup_server(
    name: str, dry_run: bool = False, current_servers: Dict[str, dict] = None
):
    """Set up a server using its configured script or pip package."""
    server = DESIRED_SERVERS[name]

    # Check if server already exists and remove it first if updating
    if current_servers is None:
        current_servers = get_current_servers()
    if name in current_servers:
        if dry_run:
            console.print(
                f"[yellow](DRY RUN) Would remove existing {name} MCP server before updating[/yellow]"
            )
        else:
            console.print(
                f"[yellow]Removing existing {name} MCP server for update...[/yellow]"
            )
            sh.claude.mcp.remove(name)

    if dry_run:
        if server.setup_script:
            args = server.extra_args.split() if server.extra_args else []
            console.print(
                f"[blue](DRY RUN) Would setup {name} using {server.setup_script} {' '.join(args)}[/blue]"
            )
        elif server.uvx_package:
            console.print(
                f"[blue](DRY RUN) Would add {name} MCP server using uvx {server.uvx_package}[/blue]"
            )
        elif server.npx_package:
            env_info = f" with env vars '{server.env_vars}'" if server.env_vars else ""
            console.print(
                f"[blue](DRY RUN) Would add {name} MCP server using npx {server.npx_package}@latest{env_info}[/blue]"
            )
        elif server.http:
            setup_http_transport(name, server, dry_run=True)
        elif server.sse:
            setup_sse_transport(name, server, dry_run=True)
        elif server.bridge:
            setup_bridge_transport(name, server, dry_run=True)
        return

    console.print(f"[blue]Setting up {name}...[/blue]")

    try:
        if server.setup_script:
            # Use existing setup script
            args = server.extra_args.split() if server.extra_args else []
            if server.env_vars:
                console.print(
                    f"[yellow]Warning: Environment variables not supported for script-based servers: {server.env_vars}[/yellow]"
                )

            # Use subprocess instead of sh library for better error handling
            script_name = server.setup_script
            cmd = [script_name] + args
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                # Print the error output for debugging
                if result.stderr:
                    console.print(f"[red]Script error output:[/red]\n{result.stderr}")
                if result.stdout:
                    console.print(f"[yellow]Script output:[/yellow]\n{result.stdout}")
                raise Exception(
                    f"Setup script {script_name} failed with exit code {result.returncode}"
                )

            # Print successful output
            if result.stdout:
                console.print(result.stdout)
        elif server.uvx_package:
            # Use uvx to install and configure the MCP server
            env_info = " with env vars" if server.env_vars else ""
            console.print(
                f"[blue]Installing {server.uvx_package} with uvx{env_info}...[/blue]"
            )

            # The command will be: uvx markitdown-mcp (or whatever the package provides)
            # For markitdown-mcp, the command is just 'markitdown-mcp'
            command = (
                server.uvx_package
                if server.uvx_package == "markitdown-mcp"
                else server.uvx_package.replace("-", "_")
            )

            console.print(f"[blue]Adding {name} MCP server...[/blue]")
            # Build command arguments
            args = [name]
            if server.env_vars:
                resolved_env = resolve_env_var(server.env_vars)
                args.extend(["-e", resolved_env])
            args.extend(["uvx", command, "-s", "user", "-t", "stdio"])

            # Add the MCP server using uvx command
            sh.claude.mcp.add(*args)
        elif server.npx_package:
            # Use npx to run the MCP server
            env_info = " with env vars" if server.env_vars else ""
            console.print(
                f"[blue]Adding {name} MCP server using npx {server.npx_package}{env_info}...[/blue]"
            )

            # Build command arguments
            args = [name, "-s", "user"]
            if server.env_vars:
                resolved_env = resolve_env_var(server.env_vars)
                args.extend(["-e", resolved_env])
            # Always use @latest for npx packages to ensure latest version
            npx_package = f"{server.npx_package}@latest"
            args.extend(["-t", "stdio", "--", "npx", "-y", npx_package])

            # Add the MCP server using npx command
            sh.claude.mcp.add(*args)
        elif server.http:
            # Use HTTP transport
            setup_http_transport(name, server, dry_run=False)
        elif server.sse:
            # Use SSE transport
            setup_sse_transport(name, server, dry_run=False)
        elif server.bridge:
            # Use bridge transport
            setup_bridge_transport(name, server, dry_run=False)

        console.print(f"[green]✅ {name} configured successfully[/green]")
    except typer.Exit:
        # Let typer.Exit propagate (for rbw authentication failures)
        raise
    except Exception as e:
        console.print(f"[red]❌ Failed to setup {name}: {e}[/red]")


def show_status(
    current: Dict[str, dict],
    to_add: List[str],
    up_to_date: List[str],
    verbose: bool = False,
):
    """Show current status in a nice table."""
    table = Table(title="MCP Server Status")
    table.add_column("Server", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Action", style="yellow")

    for name in up_to_date:
        table.add_row(name, "✅ Configured", "None needed")

    for name in to_add:
        if name in current:
            table.add_row(name, "🔄 Update needed", "Will update")
        else:
            table.add_row(name, "❌ Missing", "Will add")

    console.print(table)

    if verbose and current:
        console.print("\n[bold]Current Server Details:[/bold]")
        for name, data in current.items():
            console.print(f"\n[cyan]{name}:[/cyan]")
            console.print(data["details"])


@app.command()
def sync(
    dry_run: bool = typer.Option(False, "--dry-run", help="Show what would be done"),
    verbose: bool = typer.Option(False, "--verbose", help="Verbose output"),
):
    """Synchronize MCP servers to desired state."""
    console.print("[bold blue]🔧 Claude Code MCP Server Management[/bold blue]\n")

    if dry_run:
        console.print("[yellow]Running in DRY RUN mode[/yellow]\n")

    # Discover current state
    with console.status("Discovering current servers..."):
        current = get_current_servers()

    # Analyze what needs to be done
    to_add, up_to_date = analyze_state(current)

    # Show status
    show_status(current, to_add, up_to_date, verbose)

    if not to_add:
        console.print("\n[green]✅ All servers are in desired state![/green]")
        return

    # Sync servers
    console.print(f"\n[blue]Setting up {len(to_add)} server(s)...[/blue]")
    try:
        for name in to_add:
            setup_server(name, dry_run, current)
    except typer.Exit:
        # Propagate rbw authentication failures immediately
        raise

    if not dry_run:
        console.print("\n[green]✅ Synchronization completed![/green]")


@app.command("list")
def list_servers(
    verbose: bool = typer.Option(False, "--verbose", help="Show detailed information"),
):
    """List current and desired MCP servers."""
    current = get_current_servers()
    to_add, up_to_date = analyze_state(current)
    show_status(current, to_add, up_to_date, verbose)


@app.command("add")
def add_server(
    name: str = typer.Argument(..., help="Server name"),
    script: str = typer.Option(None, "--script", help="Setup script name"),
    uvx_package: str = typer.Option(None, "--uvx", help="Package to install via uvx"),
    npx_package: str = typer.Option(None, "--npx", help="Package to install via npx"),
    env_vars: str = typer.Option(
        None, "--env", help="Environment variables (e.g., 'KEY1=val1,KEY2=val2')"
    ),
    extra_args: str = typer.Option(
        "", "--extra-args", help="Extra script arguments (--user is automatic)"
    ),
):
    """Add a new server to desired configuration (for this session only)."""
    if not script and not uvx_package and not npx_package:
        console.print("[red]❌ Must specify either --script, --uvx, or --npx[/red]")
        return

    DESIRED_SERVERS[name] = Server(
        name, script, extra_args, uvx_package, npx_package, env_vars
    )
    method = (
        f"script '{script}'"
        if script
        else f"uvx package '{uvx_package}'"
        if uvx_package
        else f"npx package '{npx_package}'"
    )
    env_info = " with env vars" if env_vars else ""
    console.print(
        f"[green]✅ Added {name} using {method}{env_info} (--user automatic)[/green]"
    )


if __name__ == "__main__":
    app()
